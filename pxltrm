#!/usr/bin/env bash
#
# A pixel art editor for the terminal.

brushes=("█" "██" "░" "▒" "▓")


get_term_size() {
    printf '\e[18t'
    IFS=';t' read -d t -t 0.05 -sr _ lines columns

    [[ -z "$lines" || -z "$columns" ]] && \
        read -r lines columns < <(stty size)
}

clear_screen() {
    printf '\e[?7l\e[2J\e[2;1H\e[0m'
    history+=("$_")
}

print_palette() {
    for i in {1..8}; do
        ((i==color)) && block_char="▃" || block_char=" "
        ((i>7)) && i="8;5;$i"
        status+="\\e[4${i}m\\e[30m${block_width// /${block_char}}\\e[0m"
    done
}

status_line() {
    local status block_char

    # Generate block width based on terminal width.
    printf -v block_width "%$(("${columns:=80}" / 16))s" ""
    printf -v padding "%$((columns / 4 + 2))s" ""

    print_palette

    hud="colors [1-8], [d]raw, [e]rase, [c]lear, [s]ave, [o]pen, e[x]it "
    hud="${hud//\[/\[\\e[1m}"
    hud="${hud//\]/\\e[0m\]}"

    printf '\e[s\e[0;0H'
    printf '\e[0m%b' "$hud"
    printf '%b' "\\e[$((lines-2));0H${padding}${status}"
    printf '%b' "\\e[${columns}D\\e[1A${padding}${status//▃/ }"
    printf '%b' "\\e[$((lines-2));0H[\\e[1mb\\e[0m]rush: ${brush_char:=█}"
    printf '\e[u'

    unset status
}

status_line_clean() {
    printf '%b' "\\e[s\\e[$((lines-3));0H\\e[0J\\e[u"
}

save_file() {
    [[ ! -z "$1" ]] && {
        printf '%s' "${history[@]}" > "$1"
        printf '\e[s\e[%s;0H%s\e[u' "$((lines-1))" "File saved in $1"
    }
    (read -rt 1 -u 2 -p $'\e[1A'; printf '\e[99999D\e[0J\e[u\e[1A') &
}

load_file() {
    if [[ -f "$1" ]]; then
        clear_screen
        load_file="$1"
        printf '%b' "\\e[2;0H$(<"$1")\\e[2;0H"
        history=("$_" "${history[@]}")
        status_line
    fi
}

prompt() {
    printf '\e[s\e[%s;0H' "$((lines-1))"

    case "$1" in
        s) read -rp "save file: " file; save_file "${file:-$load_file}" ;;
        o) read -rp "load file: " file; load_file "$file" ;;
    esac

    printf '\e[1A\e[u'
}

cursor() {
    case "${1: -1}" in
        # Cursor Movement.
        A|k): '\e[1A' ;;
        B|j): '\e[1B' ;;
        C|l): '\e[1C' ;;
        D|h): '\e[1D' ;;

        # Color Selection.
        [1-8]) color="${1: -1}"; status_line; return ;;

        # Drawing Cells.
        d): "\\e[38;5;${color:=7}m${brush_char:=█}" ;;
        e): " " ;;

        # Brushes
        b)
            brush_char="${brushes[((j=j>=${#brushes[@]}-1?0:++j))]}"
            status_line
            return
        ;;

        # Saving/Loading
        s|o) prompt "${1: -1}"; return ;;

        # Other.
        c) clear_screen; status_line; return ;;
        x) exit ;;
        *) return ;;
    esac

    printf '%b' "$_"
    history+=("$_")
}

main() {
    clear_screen
    get_term_size
    status_line

    trap 'clear_screen; printf \\e[?7h' EXIT
    trap 'status_line_clean; get_term_size; status_line' SIGWINCH

    history=()

    while :; do
        read -rs -N 1 key; cursor "$key"
    done
}

main "$@"
